## 2.4 스프링 테스트 적용


문제점 : 

@Before 메소드가 테스트 메소드 개수만큼 반복

=> 빈이 많아지고 복잡해지면, 애플리케이션

컨텍스트 생성에 적지 않은 시간이 걸릴 수 있음

(리소스 차지 등등)



### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

; 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공

**스프링 테스트 컨텍스트 프레임 워크 적용**

*스프링 테스트 컨텍스트를 적용한 UserDaoTest*
<pre>
...
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

// 스프링 테스트 컨텍스트 프레임 워크의 JUnit확장 기능 지정
@RunWith(SpringJUnit4ClassRunner.class) 
// 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {	
	// 테스트 오브젝트가 만들어지고 나면 스프링 테스트
	// 컨텍스트에 의해 자동으로 값이 주입된다.
	@Autowired
	private ApplicationContext context;
	..
}
</pre>


*테스트 메소드의 컨텍스트 공유*

<pre>
...
	@Before
	public void setUp() {		
		System.out.println(this.context);
		System.out.println(this);
...	
</pre>


*실행 결과(주소값만)*

<pre>
@6c629d6e <br>
@462d5aee <br>
@6c629d6e <br>
@62fdb4a6 <br>
@6c629d6e <br>
@27c6e487 <br>
</pre>

=> context는 모두 동일하고 UserDaoTest는 매번 다른 인스턴스

=> 스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만

애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다

특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의

특정 필드에 주입

(수행 시간도 1.34, 0.15 , 0.06초 로 초기 할당 시만 길고 나머지는 빨라짐)



**테스트 클래스의 컨텍스트 공유**

; 스프링 테스트 컨텍스트 프레임워크는 여러 테스트 클래스 사이에서도

애플리케이션 컨텍스트를 공유하게 해줌

<pre>
@RunWith(SpringJUnit4ClassRunner.class) 
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest{..}

@RunWith(SpringJUnit4ClassRunner.class) 
@ContextConfiguration(locations="/applicationContext.xml")
public class GroupDaoTest{..}
</pre>

=> *위와 같이 있을 때 모두 하나의 애플리케이션 컨텍스트만 만들어져서 같이 이용*


**@Autowired**

; 스프링의 DI에 사용되는 특별한 애노테이션 (타입에 의한 자동와이어링)

<pre>
...
public class UserDaoTest {	
	@Autowired
	private UserDao dao;
	...
}
</pre>

=> @Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾음

(단, 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 빈을 결정 X)

SimpleDriverDataSource vs DataSource 타입 ??

=> DataSource에 정의 된 타입만 사용하고 싶으면 DataSource로 받는 게 더 좋고

꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와

느슨하게 연결해두는 편이 좋음 (DB 연결 정도 등 SimpleDriverDataSource에만

정의 된 것을 사용하고자 할때는 타입 바꿔도 괜찮음)


### 2.4.2 DI와 테스트

기존에는 UserDao와 DB 커넥션 생성 클래스 사이에는 DataSource 인터페이스를 

둠으로써, UserDao는 자신이 사용하는 오브젝트의 클래스가 무엇인지 알 필요가 없었음

BUT 절대로 DataSource의 구현 클래스를 바꾸지 않을 것이고, 개발하는 시스템은

운영 중에 항상 SimpleDriverDataSource를 통해서만 DB 커넥션을 가져올 것인데

굳이 DataSource 인터페이스를 사용하고 DI를 주입해주는 방식을 이용해야 하는 가?

==> 그래도 인터페이스를 두고 DI를 적용해야 한다.

1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없음 <br>
클래스 대신 인터페이스, new 대신 DI를 주입받게 하는 건 아주 단순하고 쉬운 작업.<br>
당장에는 클래스를 바꿔서 사용할 계획이 전혀 없더라도, 언젠가 변경이 필요한 상황이 닥쳤을 때<br>
수정에 들어가는 시간과 비용의 부담을 줄여줄 수 있다면 인터페이스&DI를 적용하는 작은 수고를<br>
하지 않을 수 없음  <br>

2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 되면 <br>
다른 차원의 서비스 기능을 도입할 수 있음 <br>
( e.g:1장에서 만들었던 DB 커넥션 카운팅 )<br>
이런 기법을 일반화해서 AOP라는 기술로 만들어 주기도 함<br>

3. 테스트 때문(단지 효율적인 테스트를 손쉽게 만들기 위해서라도 DI를 적용)


**테스트 코드에 의한 DI**






 

































































