## 1.3 DAO의 확장

모든 오브젝트는 변하지만, 다 동일한 방식으로 변하는 건 아님<br>
=> 관심사에 따라서 분리한 오브젝트들은  제각기 독특한 변화의 특징이 있음<br>
(데이터 엑세스 로직을 어떻게 만들 것인가와 DB 연결을 어떤 방법을 할 것인가 라는 두 관심을 상하위 클래스로 분리함)<br>

=> 추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분만 바꿔서 쓸 수 있게 만든 이유 <br>
 : 변화의 성격이 다른 것을 분리 & 서로 영향을 주지 않은 채, 각각 필요한 시점에 독립적으로 변경할 수 있기 위해서!<br>
 BUT 여러 단점이 많은 상속이라는 방법을 사용한 것이 불편함.
 

### 1.3.1 클래스의 분리  

(이전 작업)
- 독립된 메소드를 만들어 분리
- 상하위 클래스로 분리
<br>


(현 작업)
- 완전히 독립적인 클래스

*두 개의 독립된 클래스로 분리한 결과* 
![Alt 1-3 두 개의 독립된 클래스로 분리한 결과 ](./pic1-3.png)


*UserDao.java*
<pre>
public class UserDao {
	
	private SimpleConnectionMaker simpleConnectionMaker;
	
	public UserDao() {
		simpleConnectionMaker = new SimpleConnectionMaker();
	}
	
	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection conn = simpleConnectionMaker.makeConneection();
		...
	}
	public User get(String id) throws ClassNotFoundException, SQLException {		
		Connection conn = simpleConnectionMaker.makeConneection();
		..	
	}
</pre>

*독립시킨 DB 연결 기능인 SimpleConnectionMaker.java*
<pre>
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class SimpleConnectionMaker {
	
	public Connection makeConneection() throws ClassNotFoundException,SQLException {		
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection(
						"jdbc:mysql://localhost/springbook", "spring","book");
		return c;
	}
}
</pre>

=> main()을 이용해서 테스트 해보기

*또다른 문제점  * <br>
: N 사와 D 사의 UserDao 클래스만 공급하고 상속을 통한 DB 커넥션 기능을 확장해서 사용했던 점

해결해야하는 문제 : 
- SimpleConnectionMaker의 메소드 문제 <br>
 : makeNewConnection()을 사용해 DB 커넥션을 가져오는데, 만약 D사가 openConnection() 이라는 메소드를 사용하면, <br>
   수십, 수백개가 되면 작업 양이 너무 커짐.
- DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 함.<br>

=> UserDao가 바뀔 수 있는 정보 , i.e DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문임.<br>
(어떤 클래스가 쓰일지, 그 클래스에서 커넥션을 가져오는 메소드는 이름이 뭔지 일일이 알아야함..)


### 1.3.2 인터페이스의 도입
위의 문제를 해결하기 위해,<br> 
두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록, 중간에 추상적인 느슨한 연결고리를 만들어 주는 것<br>

**추상화** <br>
: 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업 <br>
=> 인터페이스



*인터페이스를 도입한 결과*
![Alt 1-4 인터페이스를 도입한 결과 ](./pic1-4.png)



*ConnectionMaker 인터페이스*
<pre>
package springbook.user.dao;

import java.sql.Connection;
import java.sql.SQLException;

public interface ConnectionMaker {	
	public Connection makeConnection() throws ClassNotFoundException, SQLException;

}
</pre>



*ConnectionMaker 구현 클래스*
<pre>
package springbook.user.dao;

import java.sql.Connection;
import java.sql.SQLException;

public class DConnectionMaker implements ConnectionMaker {
	@Override
	public Connection makeConnection() throws ClassNotFoundException, SQLException {
		// D 사의 독자적인 방법으로 Connection 을 생성하는 코드..
		return null;
	}	
}
</pre>



*UserDao.java*
<pre>
package springbook.user.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import springbook.user.domain.User;

public class UserDao {
	
	// 인터페이스를 통해 오브젝트에 접근하므로,
	// 구체적인 클래스 정보를 알 필요가 없음
	private ConnectionMaker connectionMaker;
	
	public UserDao() {
		//아직 까지 클래스 이름이 나옴..;
		connectionMaker = new DConnectionMaker();
	}
	
	public void add(User user) throws ClassNotFoundException, SQLException {
		// 인터페이스에 정의된 메소드를 사용하므로, 클래스가 바뀐다 해도
		// 메소드 이름이 변경될 걱정은 없음!
		Connection conn = connectionMaker.makeConnection();
		...
	}
	public User get(String id) throws ClassNotFoundException, SQLException {		
		Connection conn = connectionMaker.makeConnection();
		..
	}	
</pre>




     






























   

   