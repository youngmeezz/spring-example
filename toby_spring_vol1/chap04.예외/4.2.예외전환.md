## 예외 전환

예외를 다른 것으로 바꿔서 던지는 예외 전환은 목적은

1. 굳이 필요하지 않은 catch/throws를 줄여주는 것
2. 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것

=> JdbcTemplate의 DataAccessException 는 SQLException을 런타임 예외로 포장해주는 역할

또한, DataAccessException SQLException에 다루기 힘든 상세한 예외정보를 의미 있고

일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰임




### 4.2.1 JDBC의 한계

JDBC는 자바 표준 JDK에서도 가장 많이 사용되는 기능 중의 하나.

-> JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고, 

각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해줌.

BUT DB 종류에 상관없이 사용할 수 있는 데이터 엑세스 코드를 작성하는 일은 쉽지 않음.

표준화된 JDBC API가 DB프로그램 개발 방법을 학습하는 부담을 줄여주지만, DB를 자유롭게 바꾸어

사용할 수 있는 DB 프로그램을 작성하는 데는 2가지 걸림돌이 있음.



**비표준 SQL**

; JDBC 코드에서 사용하는 SQL. SQL은 어느 정도 표준화된 언어이고 몇 가지 표준 규약이 있긴 하지만,

대부분의 DB는 표준을 따르지 않고 비표준 문법과 기능도 제공. 이런 비표준 특정 DB 전용 문법은 매우 폭 넓게

사용되고 있음. 해당 DB의 특별한 기능을 사용하거나 최적화된 SQL을 만들 때 유용하기 때문.

=> 결국 DAO는 DB에 대해 종속적인 코드가 됨.

=> 이런 문제를 해결하기 위해 1) 표준 SQL만 사용  // 2) DB 별도의 DAO // 3) SQL을 외부로 독립 <br>
1) 표준 SQL만 사용 ==> 예제 정도의 수준이면 모를까 현실성 X



**효환성 없는 SQLException의 DB 에러정보**

; SQLException.

=> SQL문법 오류, DB 커넥션 가져오기 실패, 테이블 필드 존재 X 등등 수백가지의 원인이 있음.

=> DB마다 SQL만 다른 것이 아니라, 에러의 종류와 원인도 각각 제각각 인 점. => SQLException에 담아 던짐

=> getErrorCode()로 가져올 수 있는 DB 에러 코드는 DB벤더가 정의한 고유 한 에러 코드를 사용하기 때문에 모두 다름.

=> SQLException은 예외가 발생했을 때의 DB 상태를 담은 SQL 상태정보를 부가적으로 제공. getSQLState() 메소드로

예외 상황에 대한 상태정보를 가져올 수 있음.

=> DB별로 달라지는 에러 코드를 대신할 수 있도록, Open Group의 XOPEN SQL 스펙에 정의된 SQL 상태 코드를 따르도록 되어 있음

e.g) 통신장애로 DB 연결 실패 == 08S01, 테이블 존재X == 42S02 같은 식으로 DB 독립적인 표준 상태 코드가 정의되어 있음.

( 앞의 두 자리는 클래스 코드, 뒤의 세 자리는 서브클래스 코드로 분류 )

BUT 문제는, DB의 JDBC 드라이버에서 SQLException을 담을 상태 코드를 정확하게 만들어주지 않는다는 점.

-> 어떤 경우에는 아예 표준 코드와는 상관없는 엉뚱한 값이 들어 있기도 하고, 어떤 DB는 반만 따르고 등등

=> 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태코드를 가진 SQLException만으로는 DB에 독립적인

유연한 코드를 작성하는 건 불가능에 가까움.



### 4.2.2 DB 에러 코드 매핑을 통한 전환
; DB 종류가 바뀌더라도 DAO를 수정하지 않으려면 이 두가지 문제를 해결 해야 함. SQL문은 뒤에서 설명,

여기서는 SQLException의 비표준 에러 코드와 SQL 상태정보에 대한 해결책을 찾아봄

-> DB별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해주는 기능을 만드는 것.

e.g) 키 값 중복은 MySQL == 1062, Oracle == 1, DB2 == -803 에러 코드

-> 스프링은 DataAccessException의 서브 클래스로 세분화 된 예외클래스들을 정의하고 있음.

<table>
	<tr>
		<th>BadSqlGrammarException</th>
		<td>SQL문법 에러</td>
	</tr>
	<tr>
		<th>DataAccessResourceFailureException</th>
		<td>DB 커넥션을 가져오지 못했을 때</td>
	</tr>	
	<tr>
		<th>DataIntegrityViolationException</th>
		<td>데이터의 제약 조건 위배 등 일관성을 지키지 않는 작업</td>
	</tr>
	<tr>
		<th>DuplicatedKeyException</th>
		<td>중복 키</td>
	</tr>
</table>

---

> 오클 에러 코드 매핑 파일 (org.springframework.jdbc.support.sql-error-codes.xml 중 )

<pre>
&lt;bean id=&quot;Oracle&quot; class=&quot;org.springframework.jdbc.support.SQLErrorCodes&quot;&gt;
		&lt;property name=&quot;badSqlGrammarCodes&quot;&gt;
			&lt;value&gt;900,903,904,917,936,942,17006&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name=&quot;invalidResultSetAccessCodes&quot;&gt;
			&lt;value&gt;17003&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name=&quot;duplicateKeyCodes&quot;&gt;
			&lt;value&gt;1&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name=&quot;dataIntegrityViolationCodes&quot;&gt;
			&lt;value&gt;1400,1722,2291,2292&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name=&quot;dataAccessResourceFailureCodes&quot;&gt;
			&lt;value&gt;17002,17447&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name=&quot;cannotAcquireLockCodes&quot;&gt;
			&lt;value&gt;54&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name=&quot;cannotSerializeTransactionCodes&quot;&gt;
			&lt;value&gt;8177&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name=&quot;deadlockLoserCodes&quot;&gt;
			&lt;value&gt;60&lt;/value&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

</pre>

-> JdbcTemplate은 SQLException을 단지 런타임 예외인 DataAccessException으로 포장하는 것이 아니라,

DB 에러 코드를 DataAccessException 계층구조의 클래스 중 하나로 매핑

=> 드라이버나 DB 메타정보를 참고해서 DB 종류를 확인하고 DB별로 미리 준비된 위와같은 매핑정보를

참고해서 적절한 예외 클래스를 선택하기 때문에 DB가 달라져도 같은 종류의 에러라면 동일한

예외를 받을 수 있는 것. 


> JdbcTemplate이 제공하는 예외 전환 기능을 이용하는 add()메소드

<pre>
public void add(final User user) throws DuplicateKeyException {		
	this.jdbcTemplate.update("insert into users(id, name, password) values(?,?,?)",
			user.getId(), user.getName(), user.getPassword() );
}
</pre>

-> DB종류에 상관없이 중복 키로 인해 발생하는 에러는 DataAccessException의 서브 클래스인 DuplicateKeyException

으로 매핑돼서 던저짐

---

=> 중복키 에러가 발생했을 때 애플리케이션에서 직접 정의한 예외를 발생시키고 싶은 경우가 존재

( 개발 정책 때문일 수도, DuplicateKeyExcepion의 런타임 예외이기 때문에 강제하지 않는 것이 불안 등등 )

---

> 중복키 예외의 전환

<pre>
public void add(final User user) throws DuplicatedUserIdException {
	try {
		this.jdbcTemplate.update("insert into users(id, name, password) values(?,?,?)",
				user.getId(), user.getName(), user.getPassword() );
	}
	catch(DuplicateKeyException e) {
		// 로그를 남기는 등의 필요한 작업
		// 예외를 전환할때는 원인이 되는 예외를 중첩하는 것이 좋음
		throw new DuplicatedUserIdException(e);
	}
}
</pre>

---


### 4.2.3 DAO 인터페이스와 DataAccessException 계층 구조
; DataAccessException는 JDBC의 SQLException을 전환하는 용도로만 만들어진

것이 아니라, JDBC 외의 데이터 엑세스 기술에서 발생하는 예외에도 적용 됨.

=> 자바에는 JDBC 외에도 데이터 엑세스를 위한 표준 기술이 존재.

=> DataAccessException은 의미가 같은 예외라면 데이터 엑세스 기술의 종류와 상관없이

일관된 예외가 발생하도록 만들어 줌.

**DAO 인터페이스와 구현의 분리**

*DAO를 굳이 따로 만들어서 사용하는 이유?* <br>
데이터 엑세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해. 또한, 분리된 DAO는 <br>
전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있게 만들기 위해서이기도 함.















 


 












































